import pandas as pd
from custom_plots import *


def calculate_collinearity(df, min_threshold=0.5, return_result=False, plot=True):
    '''
    save absolute value of correlation matrix as a data frame
    converts all values to absolute value
    stacks the row:column pairs into a multindex
    reset the index to set the multindex to seperate columns
    sort values. 0 is the column automatically generated by the stacking
    
    SOURCE: FLATIRON 19.6 "Multicollinearity of Features - Lab"
    https://github.com/learn-co-curriculum/dsc-multicollinearity-of-features-lab/tree/master
    
    Parameters:
    -----------
    df : DataFrame to be analyzed
    min_threshold : minimum correlation threshold to print
    return_result : binary flag to return the resulting DataFrame
    plot : binary flag to produce heatmap / correlation matrix

    Returns:
    --------
    df_corr : correlation DataFrame
    '''

    
    
    df_corr=df.corr().abs().stack().reset_index().sort_values(0, ascending=False)

    # zip the variable name columns (Which were only named level_0 and level_1 by default) in a new column named "pairs"
    df_corr['pairs'] = list(zip(df_corr.level_0, df_corr.level_1))

    # set index to pairs
    df_corr.set_index(['pairs'], inplace = True)

    #d rop level columns
    df_corr.drop(columns=['level_1', 'level_0'], inplace = True)

    # rename correlation column as cc rather than 0
    df_corr.columns = ['cc']

    # drop duplicates. This could be dangerous if you have variables perfectly correlated with variables other than themselves.
    # for the sake of exercise, kept it in.
    df_corr.drop_duplicates(inplace=True)

    if plot:
        custom_plot_matrix(df, max_corr=1)

    print(f'Features with correlation higher than {min_threshold}:')
    display (df_corr[df_corr.cc>min_threshold])
    
    if return_result:
        return df_corr[df_corr.cc>min_threshold]